# Exploit Development
- [Shellcoding](#shellcoding)
    - [Shellcodes](#shellcodes)
    - [Shellcoding Techniques](#shellcoding-techniques)

## Shellcoding
### Shellcodes
- A shellcode is the hex representation of a binary's executable machine code.
- **Assembly to Machine Code**
    - Each x86 instruction and each register has its own binary machine code (usually represented in hex). For example, the push rax instruction has the machine code 50, while push rbx has the machine code 53, and so on. When we assemble our code with nasm, it converts our assembly instructions to their respective machine code so that the processor can understand them.
    - We will use pwntools to assemble and disassemble our machine code

    ```bash
    sudo pip3 install pwntools

    # we can use pwn asm to assemble any assembly code into its shellcode
    pwn asm 'push rax'  -c 'amd64'
    ```

> [!NOTE]
> We used the `-c 'amd64'` flag to ensure the tool properly interprets our assembly code for x86_64

- **Extract Shellcode**
    - Python script to extract shellcode from any binary. shellcoder.py:

    ```python
    #!/usr/bin/python3

    import sys
    from pwn import *

    context(os="linux", arch="amd64", log_level="error")

    file = ELF(sys.argv[1])
    shellcode = file.section(".text")
    print(shellcode.hex())
    print("%d bytes - Found NULL byte" % len(shellcode)) if [i for i in shellcode if i == 0] else print("%d bytes - No NULL bytes" % len(shellcode))

    ```
    - Python script to run shellcode. Loader.py:
    ```python
    #!/usr/bin/python3
    import sys
    from pwn import *

    context(os="linux", arch="amd64", log_level="error")

    run_shellcode(unhex(sys.argv[1])).interactive()
    ``` 

- **Debugging Shellcode**
    - We will build our shellcode to an elf binary and then use this binary with gdb so we can debug. 
    - Python script to convert shellcode into binary and save it. assembler.py: 
    ```python
    #!/usr/bin/python3

    import sys, os, stat
    from pwn import *

    context(os="linux", arch="amd64", log_level="error")

    ELF.from_bytes(unhex(sys.argv[1])).save(sys.argv[2])
    os.chmod(sys.argv[2], stat.S_IEXEC)
    ```

### Shellcoding Techniques

- To be able to produce a working shellcode, there are three main Shellcoding Requirements our assembly code must meet:
    1. Does not contain variables
    2. Does not refer to direct memory addresses
    3. Does not contain any NULL bytes 00

1. Variables
    - There are many techniques we can use to avoid using variables, like:

        - Moving immediate strings to registers
        - Pushing strings to the Stack, and then use them

```bash
    mov rbx, 'y!'
    push rbx
    mov rbx, 'B Academ'
    push rbx
    mov rbx, 'Hello HT'
    push rbx
    mov rsi, rsp
```

> [!NOTE]
> Whenever we push a string to the stack, we have to push a 00 before it to terminate the string.

2. Addresses
    - To be able to do so, we cannot reference direct memory address (i.e. call 0xffffffffaa8a25ff), and instead only make calls to labels (i.e. call loopFib) or relative memory addresses (i.e., call 0x401020). 

    - If we ever had any calls or references to direct memory addresses, we can fix that by:

        - Replacing with calls to labels or rip-relative addresses (for calls and loops)
        - Push to the Stack and use rsp as the address (for mov and other assembly instructions)

3. NULL

    - NULL characters (or 0x00) are used as string terminators in assembly and machine code, and so if they are encountered, they will cause issues and may lead the program to terminate early.

    - This commonly happens when moving a small integer into a large register, so the integer gets padded with an extra 00 to fit the larger register's size.

    - To avoid having these NULL bytes, we must use registers that match our data size.
```bash
    xor rbx, rbx
    mov bx, 'y!'
```

> [!TIP]
> If we ever need to move 0 to a register, we can zero-out that register. Likewise, if we even need to push 0 to the stack (e.g. for String Termination) we can zero-out any register, and then push that register to the stack.

