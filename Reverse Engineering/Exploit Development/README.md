# Exploit Development
- [Shellcoding](#shellcoding)
    - [Shellcodes](#shellcodes)

## Shellcoding
### Shellcodes
- A shellcode is the hex representation of a binary's executable machine code.
- **Assembly to Machine Code**
    - Each x86 instruction and each register has its own binary machine code (usually represented in hex). For example, the push rax instruction has the machine code 50, while push rbx has the machine code 53, and so on. When we assemble our code with nasm, it converts our assembly instructions to their respective machine code so that the processor can understand them.
    - We will use pwntools to assemble and disassemble our machine code

    ```bash
    sudo pip3 install pwntools

    # we can use pwn asm to assemble any assembly code into its shellcode
    pwn asm 'push rax'  -c 'amd64'
    ```

> [!NOTE]
> We used the `-c 'amd64'` flag to ensure the tool properly interprets our assembly code for x86_64

- **Extract Shellcode**
    - Python script to extract shellcode from any binary. shellcoder.py:

    ```python
    #!/usr/bin/python3

    import sys
    from pwn import *

    context(os="linux", arch="amd64", log_level="error")

    file = ELF(sys.argv[1])
    shellcode = file.section(".text")
    print(shellcode.hex())
    ```
    - Python script to run shellcode. Loader.py:
    ```python
    #!/usr/bin/python3
    import sys
    from pwn import *

    context(os="linux", arch="amd64", log_level="error")

    run_shellcode(unhex(sys.argv[1])).interactive()
    ``` 

- **Debugging Shellcode**
    - We will build our shellcode to an elf binary and then use this binary with gdb so we can debug. 
    - Python script to convert shellcode into binary and save it. assembler.py: 
    ```python
    #!/usr/bin/python3

    import sys, os, stat
    from pwn import *

    context(os="linux", arch="amd64", log_level="error")

    ELF.from_bytes(unhex(sys.argv[1])).save(sys.argv[2])
    os.chmod(sys.argv[2], stat.S_IEXEC)
    ```
